// Generated by CoffeeScript 1.9.3
var Gyro;

Gyro = (function() {
  return $(function() {
    var ambientlight, angularSpeed, animate, camera, channel, container, cube, cylinder, directionalLight, getGrade, getState, height, init, lastTime, nutation, onMouseClick, precession, projector, render, renderer, rotation, scene, selectedMaterial, setState, state, unselectedMaterial, updateMaterials, width;
    width = 400;
    height = 400;
    container = void 0;
    renderer = void 0;
    scene = void 0;
    camera = void 0;
    projector = void 0;
    ambientlight = void 0;
    directionalLight = void 0;
    cylinder = void 0;
    cube = void 0;
    unselectedMaterial = void 0;
    selectedMaterial = void 0;
    precession = {
      id: 'precession',
      value: 20
    };
    nutation = {
      id: 'nutation',
      value: 30
    };
    rotation = {
      id: 'rotation',
      value: 0
    };
    console.log('loaded');
    [precession, nutation, rotation].map(function(s) {
      return s.slider = $('#' + s.id).CircularSlider({
        radius: 50,
        animate: false,
        value: s.value,
        slide: function(ui, value) {
          return s.value = value;
        }
      });
    });
    angularSpeed = 0;
    lastTime = 0;
    state = {
      'selectedObjects': {
        'cylinder': false,
        'cube': false
      }
    };
    channel = void 0;
    init = function() {
      var ambientLight, contextNames, e, heightSegments, i, radiusSegments, testCanvas, webglContext;
      container = document.getElementById('container');
      testCanvas = document.createElement('canvas');
      webglContext = null;
      contextNames = ['experimental-webgl', 'webgl', 'moz-webgl', 'webkit-3d'];
      radiusSegments = void 0;
      heightSegments = void 0;
      i = 0;
      while (i < contextNames.length) {
        try {
          webglContext = testCanvas.getContext(contextNames[i]);
          if (webglContext) {
            break;
          }
        } catch (_error) {
          e = _error;
        }
        i++;
      }
      if (webglContext) {
        renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        radiusSegments = 50;
        heightSegments = 50;
      } else {
        renderer = new THREE.CanvasRenderer;
        radiusSegments = 10;
        heightSegments = 10;
      }
      renderer.setSize(width, height);
      renderer.setClearColor(0xFFFFFF, 1);
      container.appendChild(renderer.domElement);
      scene = new THREE.Scene;
      camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
      camera.position.x = 400;
      camera.position.y = 400;
      camera.position.z = 200;
      camera.up.set(0, 0, 1);
      camera.lookAt(new THREE.Vector3(0, 0, 0));
      camera.updateProjectionMatrix();
      unselectedMaterial = new THREE.MeshPhongMaterial({
        specular: '#a9fcff',
        color: '#00abb1',
        emissive: '#006063',
        shininess: 100
      });
      selectedMaterial = new THREE.MeshPhongMaterial({
        specular: '#a9fcff',
        color: '#abb100',
        emissive: '#606300',
        shininess: 100
      });
      if (!webglContext) {
        unselectedMaterial.overdraw = 1.0;
        selectedMaterial.overdraw = 1.0;
      }
      cube = new THREE.Mesh(new THREE.CubeGeometry(100, 150, 200), unselectedMaterial);
      cube.position.x = 0;
      cube.overdraw = true;
      cube.quaternion.setFromAxisAngle(new THREE.Vector3(1, 1, 1), Math.PI / 3);
      scene.add(cube);
      ambientLight = new THREE.AmbientLight(0x222222);
      scene.add(ambientLight);
      directionalLight = new THREE.DirectionalLight(0xffffff);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);
      projector = new THREE.Projector;
      renderer.domElement.addEventListener('click', onMouseClick, false);
      animate();
    };
    animate = function() {
      requestAnimationFrame(animate);
      render();
    };
    render = function() {
      var angleChange, q, qaa, time, timeDiff;
      time = (new Date).getTime();
      timeDiff = time - lastTime;
      angleChange = angularSpeed * timeDiff / 1000;
      rotation.value += angleChange;
      rotation.value = rotation.value % 360;
      rotation.slider.setValue(Math.floor(rotation.value));
      lastTime = time;
      q = new THREE.Quaternion();
      qaa = function(x, y, z, a) {
        return new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(x, y, z), a);
      };
      q.multiply(qaa(0, 0, 1, Math.PI * precession.value / 180));
      q.multiply(qaa(1, 0, 0, Math.PI * nutation.value / 180));
      q.multiply(qaa(0, 0, 1, Math.PI * rotation.value / 180));
      cube.quaternion.copy(q);
      renderer.render(scene, camera);
    };
    onMouseClick = function(event) {
      var intersects, raycaster, vector;
      vector = void 0;
      raycaster = void 0;
      intersects = void 0;
      vector = new THREE.Vector3(event.clientX / width * 2 - 1, -(event.clientY / height) * 2 + 1, 1);
      projector.unprojectVector(vector, camera);
      raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
      intersects = raycaster.intersectObjects(scene.children);
      if (intersects.length > 0) {
        if (intersects[0].object === cube) {
          state.selectedObjects.cube = !state.selectedObjects.cube;
          if (angularSpeed > 0) {
            angularSpeed = 0;
          } else {
            angularSpeed = 200;
          }
        }
        updateMaterials();
      }
    };
    updateMaterials = function() {
      if (state.selectedObjects.cube) {
        cube.material = selectedMaterial;
      } else {
        cube.material = unselectedMaterial;
      }
    };
    getGrade = function() {
      return JSON.stringify(state['selectedObjects']);
    };
    getState = function() {
      return JSON.stringify(state);
    };
    setState = function() {
      var stateStr;
      stateStr = arguments.length === 1 ? arguments[0] : arguments[1];
      state = JSON.parse(stateStr);
      updateMaterials();
    };
    if (window.parent !== window) {
      channel = Channel.build({
        window: window.parent,
        origin: '*',
        scope: 'JSInput'
      });
      channel.bind('getGrade', getGrade);
      channel.bind('getState', getState);
      channel.bind('setState', setState);
    }
    init();
    return {
      getState: getState,
      setState: setState,
      getGrade: getGrade
    };
  });
})();
