// Generated by CoffeeScript 1.9.3
var Gyro, lsum, stepRungeKutta;

THREE.Quaternion.prototype.addQuaternion = function(q, b) {
  if (b == null) {
    b = 1;
  }
  return new THREE.Quaternion(this.x + q.x * b, this.y + q.y * b, this.z + q.z * b, this.w + q.w * b);
};

THREE.Vector3.prototype.addVector3 = function(v, b) {
  if (b == null) {
    b = 1;
  }
  return new THREE.Vector3(this.x + v.x * b, this.y + v.y * b, this.z + v.z * b);
};

lsum = function(vec1, vec2, k1) {
  if (k1 == null) {
    k1 = 1;
  }
  return vec1.map(function(e, i) {
    return vec1[i] * k1 + vec2[i];
  });
};

stepRungeKutta = function(vec, func, t, dt) {
  var k1, k2, k3, k4;
  k1 = func(t, vec);
  k2 = func(t + dt / 2, lsum(k1, vec, dt / 2));
  k3 = func(t + dt / 2, lsum(k2, vec, dt / 2));
  k4 = func(t + dt, lsum(k3, vec, dt));
  return vec.map(function(e, i) {
    return e + dt * ((k1[i] + k4[i]) / 6 + (k2[i] + k3[i]) / 3);
  });
};

Gyro = (function() {
  return $(function() {
    var J, MAX_POINTS, ambientlight, angularSpeed, animate, camera, channel, container, controls, cube, cylinder, degree, directionalLight, getDerivative, getGrade, getState, gyroGeometry, height, init, lastTime, line, max_nutation, model, nutData, nutation, nutationDot, omega, pi, plot, plotData, precession, precessionDot, raycaster, render, renderer, rotation, rotationDot, rotationVelocity, scene, selectedMaterial, setState, simulationState, startTime, state, stopSimulation, unselectedMaterial, updateInitialConditions, updateMaterials, weight, width;
    pi = Math.PI;
    degree = pi / 180;
    width = 400;
    height = 300;
    container = void 0;
    renderer = void 0;
    scene = void 0;
    camera = void 0;
    raycaster = new THREE.Raycaster();
    ambientlight = void 0;
    directionalLight = void 0;
    cylinder = void 0;
    cube = void 0;
    unselectedMaterial = void 0;
    selectedMaterial = void 0;
    controls = void 0;
    model = void 0;
    line = void 0;
    startTime = (new Date).getTime();
    plot = void 0;
    nutData = [];
    plotData = {
      theta: {
        data: [[0, 0]],
        label: "theta",
        color: 1
      },
      psi: {
        data: [[0, 0]],
        label: "psi",
        color: 0
      }
    };
    MAX_POINTS = 5000;
    simulationState = false;
    rotationVelocity = {
      precession: 30,
      nutation: 0,
      rotation: 400
    };
    omega = new THREE.Vector3(0, 0, 5);
    weight = 10;
    gyroGeometry = {
      angle: 36 * degree,
      length: 150,
      centerMass: 113.8,
      cubesSize: 30
    };
    precession = {
      id: 'precession',
      value: 0
    };
    nutation = {
      id: 'nutation',
      value: 36
    };
    rotation = {
      id: 'rotation',
      value: 0
    };
    precessionDot = {
      id: 'precession',
      value: 0
    };
    nutationDot = {
      id: 'nutation',
      value: 0
    };
    rotationDot = {
      id: 'rotation',
      value: 3.0
    };
    max_nutation = 72 * degree;
    J = {
      A: 7,
      B: 7,
      C: 10
    };
    J.CB = J.C - J.B;
    J.BA = J.B - J.A;
    J.AC = J.A - J.C;
    angularSpeed = 0;
    lastTime = 0;
    state = {
      'selectedObjects': {
        'cylinder': false,
        'cube': false
      }
    };
    channel = void 0;
    updateInitialConditions = function() {
      var cos, phi, phid, psi, psid, q, qaa, ref, sin, theta, thetad;
      ref = [Math.sin, Math.cos], sin = ref[0], cos = ref[1];
      psi = precession.value * degree;
      theta = nutation.value * degree;
      phi = rotation.value * degree;
      psid = precessionDot.value;
      thetad = nutationDot.value;
      phid = rotationDot.value;
      omega.x = psid * sin(theta) * sin(phi) + thetad * cos(phi);
      omega.y = psid * sin(theta) * cos(phi) - thetad * sin(phi);
      omega.z = psid * cos(theta) + phid;
      q = new THREE.Quaternion();
      qaa = function(x, y, z, a) {
        return new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(x, y, z), a);
      };
      q.multiply(qaa(0, 0, 1, psi));
      q.multiply(qaa(1, 0, 0, theta));
      q.multiply(qaa(0, 0, 1, phi));
      model.quaternion.copy(q);
      return model.position.z = Math.cos(theta) * gyroGeometry.centerMass;
    };
    stopSimulation = function() {
      simulationState = false;
      return $(".play.on").toggleClass("on");
    };
    init = function() {
      var ambientLight, contextNames, e, heightSegments, i, loader, manager, onError, onProgress, radiusSegments, testCanvas, webglContext;
      container = document.getElementById('container');
      testCanvas = document.createElement('canvas');
      webglContext = null;
      contextNames = ['experimental-webgl', 'webgl', 'moz-webgl', 'webkit-3d'];
      radiusSegments = void 0;
      heightSegments = void 0;
      i = 0;
      while (i < contextNames.length) {
        try {
          webglContext = testCanvas.getContext(contextNames[i]);
          if (webglContext) {
            break;
          }
        } catch (_error) {
          e = _error;
        }
        i++;
      }
      if (webglContext) {
        renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        radiusSegments = 50;
        heightSegments = 50;
      } else {
        renderer = new THREE.CanvasRenderer;
        radiusSegments = 10;
        heightSegments = 10;
      }
      renderer.setSize(width, height);
      renderer.setClearColor(0xFFFFFF, 1);
      container.appendChild(renderer.domElement);
      scene = new THREE.Scene;
      camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
      camera.position.x = 400;
      camera.position.y = 400;
      camera.position.z = 200;
      camera.up.set(0, 0, 1);
      camera.lookAt(new THREE.Vector3(0, 0, 200));
      camera.updateProjectionMatrix();
      controls = new THREE.TrackballControls(camera, container);
      controls.rotateSpeed = 1.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.8;
      controls.noZoom = false;
      controls.noPan = false;
      controls.staticMoving = true;
      controls.dynamicDampingFactor = 0.3;
      controls.keys = [65, 83, 68];
      controls.addEventListener('change', render);
      unselectedMaterial = new THREE.MeshPhongMaterial({
        specular: '#a9fcff',
        color: '#00abb1',
        emissive: '#006063',
        shininess: 100
      });
      selectedMaterial = new THREE.MeshPhongMaterial({
        specular: '#a9fcff',
        color: '#abb100',
        emissive: '#606300',
        shininess: 100
      });
      if (!webglContext) {
        unselectedMaterial.overdraw = 1.0;
        selectedMaterial.overdraw = 1.0;
      }
      model = new THREE.Group();
      (function() {
        var cone, cone_height, cone_radius, geometry, shift, size;
        cone_height = gyroGeometry.length * Math.cos(gyroGeometry.angle / 2);
        cone_radius = gyroGeometry.length * Math.sin(gyroGeometry.angle / 2);
        shift = gyroGeometry.centerMass;
        geometry = new THREE.CylinderGeometry(cone_radius, 0, cone_height, radiusSegments, heightSegments);
        cone = new THREE.Mesh(geometry, unselectedMaterial);
        cone.rotation.x = pi / 2;
        cone.position.z = cone_height / 2 - shift;
        size = gyroGeometry.cubesSize;
        geometry = new THREE.CubeGeometry(size, size, size);
        return [0, 1, 2, 3].map(function(i) {
          var cubic;
          cubic = new THREE.Mesh(geometry, unselectedMaterial);
          cubic.position.z = cone_height - shift;
          cubic.position.x = cone_radius * Math.cos(pi * i / 2);
          return cubic.position.y = cone_radius * Math.sin(pi * i / 2);
        });
      })();
      manager = new THREE.LoadingManager();
      manager.onProgress = function(item, loaded, total) {
        return console.log(item, loaded, total);
      };
      onProgress = function(xhr) {
        var percentComplete;
        if (xhr.lengthComputable) {
          percentComplete = xhr.loaded / xhr.total * 100;
          return console.log(Math.round(percentComplete, 2) + '% downloaded');
        }
      };
      onError = function(xhr) {
        return xhr;
      };
      loader = new THREE.OBJLoader(manager);
      loader.load('gyro.obj', function(object) {
        object.traverse(function(child) {
          if (child instanceof THREE.Mesh) {
            return child.material = unselectedMaterial;
          }
        });
        object.rotation.x = pi / 2;
        object.scale.set(14, 14, 14);
        object.position.z += 113.8;
        object.position.z -= gyroGeometry.centerMass;
        return model.add(object);
      }, onProgress, onError);
      scene.add(model);
      (function() {
        var geometry, material, plane;
        geometry = new THREE.PlaneGeometry(300, 300, 32);
        material = new THREE.MeshBasicMaterial({
          color: 0xffff00,
          side: THREE.DoubleSide
        });
        plane = new THREE.Mesh(geometry, material);
        return scene.add(plane);
      })();
      (function() {
        var geometry, index, j, material, positions, ref, results, x, y, z;
        geometry = new THREE.BufferGeometry();
        positions = new Float32Array(MAX_POINTS * 3);
        geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.attributes.position.len = 0;
        geometry.setDrawRange(0, 0);
        material = new THREE.LineBasicMaterial({
          color: 0xDF4949,
          linewidth: 2
        });
        line = new THREE.Line(geometry, material);
        x = y = z = index = 0;
        results = [];
        for (i = j = 0, ref = MAX_POINTS; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          positions[index] = x;
          index++;
          positions[index] = y;
          index++;
          positions[index] = 0;
          index++;
          x += (Math.random() - 0.5) * 30;
          y += (Math.random() - 0.5) * 30;
          results.push(z += (Math.random() - 0.5) * 30);
        }
        return results;
      })();
      scene.add(line);
      ambientLight = new THREE.AmbientLight(0x222222);
      scene.add(ambientLight);
      directionalLight = new THREE.DirectionalLight(0xffffff);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);
      $('.play').click(function(el) {
        var k, results, v;
        console.log('Clicked');
        $(this).toggleClass('on');
        simulationState = $(this).hasClass('on');
        if (simulationState === true) {
          startTime = (new Date).getTime();
          line.geometry.setDrawRange(0, 0);
          line.geometry.attributes.position.len = 0;
          results = [];
          for (k in plotData) {
            v = plotData[k];
            console.log(k);
            results.push(v.data = []);
          }
          return results;
        }
      });
      console.log('loaded');
      [precession, nutation, rotation].map(function(s) {
        return s.slider = $('#' + s.id + ' .knob').CircularSlider({
          radius: 50,
          animate: false,
          value: s.value,
          shape: s.id === 'nutation' ? 'Half Circle' : 'Full Circle Right',
          max: s.id === 'nutation' ? 179 : void 0,
          clockwise: false,
          slide: function(ui, value) {
            s.value = value;
            return updateInitialConditions();
          }
        });
      });
      [precessionDot, nutationDot, rotationDot].map(function(s) {
        var $el;
        $el = $('#' + s.id + ' .der-input');
        s.value = parseFloat($el.val());
        return $el.on('change', function(el) {
          s.value = parseFloat($el.val());
          return updateInitialConditions();
        });
      });
      updateInitialConditions();
      plot = $('#plot').plot([plotData.theta, plotData.psi]).data("plot");
      render();
      animate();
    };
    animate = function() {
      requestAnimationFrame(animate);
      controls.update();
      render();
    };
    getDerivative = function(t, arg, arg1) {
      var M, mx, my, mz, p, pqrd, q, qs, quatd, r, ref, w, w2, wx, wy, wz, x, x2, xy, xz, y, y2, yz, z, z2;
      w = arg[0], x = arg[1], y = arg[2], z = arg[3], p = arg[4], q = arg[5], r = arg[6];
      mx = arg1[0], my = arg1[1], mz = arg1[2];
      ref = [w * x, w * y, w * z, x * y, y * z, x * z, w * w, x * x, y * y, z * z], wx = ref[0], wy = ref[1], wz = ref[2], xy = ref[3], yz = ref[4], xz = ref[5], w2 = ref[6], x2 = ref[7], y2 = ref[8], z2 = ref[9];
      qs = w2 - x2 - y2 - z2;
      M = [-my * w2 - 2 * mz * wx + my * x2 - 2 * mx * xy - my * y2 + 2 * mx * wz - 2 * mz * yz + my * z2, mx * w2 + mx * x2 - 2 * mz * wy + 2 * my * xy - mx * y2 + 2 * my * wz + 2 * mz * xz - mx * z2, 0];
      pqrd = [(M[0] - J.CB * q * r) / J.A, (M[1] - J.AC * r * p) / J.B, (M[2] - J.BA * p * q) / J.C];
      quatd = [-(p * x + q * y + r * z) / 2.0, (p * w + r * y - q * z) / 2.0, (q * w - r * x + p * z) / 2.0, (r * w + q * x - p * y) / 2.0];
      return [quatd[0], quatd[1], quatd[2], quatd[3], pqrd[0], pqrd[1], pqrd[2]];
    };
    render = function() {
      var cosAngle, dt, i, nutAngle, p, pos, proj, psiAngle, q, r, ref, t, time, vert, w, x, y, z;
      time = (new Date).getTime();
      t = (time - startTime) / 1000.0;
      dt = (time - lastTime) / 1000;
      rotationVelocity.precession = 90 * Math.abs(Math.sin(pi * nutation.value / 180));
      if (simulationState) {
        ref = stepRungeKutta([model.quaternion.w, model.quaternion.x, model.quaternion.y, model.quaternion.z, omega.x, omega.y, omega.z], (function(t, v) {
          return getDerivative(t, v, [0, 0, -weight]);
        }), time, dt), w = ref[0], x = ref[1], y = ref[2], z = ref[3], p = ref[4], q = ref[5], r = ref[6];
        omega.fromArray([p, q, r]);
        model.quaternion.fromArray([x, y, z, w]).normalize();
        cosAngle = w * w - x * x - y * y + z * z;
        model.position.z = cosAngle * gyroGeometry.centerMass;
        nutAngle = Math.acos(cosAngle);
        psiAngle = Math.atan2(w * y + x * z, w * x - y * z);
        proj = gyroGeometry.centerMass * Math.sin(nutAngle);
        vert = [-proj * Math.sin(psiAngle), proj * Math.cos(psiAngle), 0];
        pos = line.geometry.attributes.position;
        plotData.theta.data.push([t, nutAngle / degree]);
        plotData.psi.data.push([t, psiAngle / degree]);
        plot.setData([plotData.theta, plotData.psi]);
        plot.setupGrid();
        plot.draw();
        if (pos.len < MAX_POINTS) {
          i = pos.len;
          pos.array[3 * i + 0] = vert[0];
          pos.array[3 * i + 1] = vert[1];
          pos.array[3 * i + 2] = vert[2];
          pos.len += 1;
          line.geometry.setDrawRange(0, i + 1);
          line.geometry.attributes.position.needsUpdate = true;
        } else {
          stopSimulation();
        }
        if (nutAngle > max_nutation) {
          stopSimulation();
          alert("У вас упало");
        }
      }
      lastTime = time;
      renderer.render(scene, camera);
    };
    updateMaterials = function() {
      var child, j, len, material, ref, results;
      material = state.selectedObjects.cube ? selectedMaterial : unselectedMaterial;
      ref = model.children;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        results.push(child.material = material);
      }
      return results;
    };
    getGrade = function() {
      return JSON.stringify(state['selectedObjects']);
    };
    getState = function() {
      return JSON.stringify(state);
    };
    setState = function() {
      var stateStr;
      stateStr = arguments.length === 1 ? arguments[0] : arguments[1];
      state = JSON.parse(stateStr);
      updateMaterials();
    };
    if (window.parent !== window) {
      channel = Channel.build({
        window: window.parent,
        origin: '*',
        scope: 'JSInput'
      });
      channel.bind('getGrade', getGrade);
      channel.bind('getState', getState);
      channel.bind('setState', setState);
    }
    init();
    return {
      getState: getState,
      setState: setState,
      getGrade: getGrade
    };
  });
})();
